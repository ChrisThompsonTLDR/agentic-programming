"""
AgentFactory - Creates agent instances from parsed markdown definitions.
"""
import re
from typing import Dict, Any, Optional
from pathlib import Path


class Agent:
    """Represents an autonomous agent with a specific role and instructions."""
    
    def __init__(self, agent_def: Dict[str, Any], guardrails: Optional[Dict] = None):
        """
        Initialize an agent.
        
        Args:
            agent_def: Agent definition from MarkdownParser
            guardrails: Optional guardrails/constraints to apply
        """
        self.title = agent_def.get("title", "Unnamed Agent")
        self.phase = agent_def.get("phase", "Unknown")
        self.command_number = agent_def.get("command_number", "00")
        self.system_prompt = agent_def.get("system_prompt", "")
        self.role_section = agent_def.get("role_section", "")
        self.preparation = agent_def.get("preparation", "")
        self.steps = agent_def.get("steps", "")
        self.filepath = agent_def.get("filepath", "")
        self.guardrails = guardrails or {}
        
    def __repr__(self):
        return f"Agent({self.command_number}: {self.title}, phase={self.phase})"
    
    def execute(self, user_input: str, context: Dict[str, Any] = None) -> Dict[str, Any]:
        """
        Execute the agent with user input (hypothetical OpenAI SDK usage).
        
        This is a scaffold showing how the agent would be invoked with actual
        OpenAI SDK. In a real implementation, this would use openai.Agent or similar.
        
        Args:
            user_input: User's goal or request
            context: Additional context (epic folder, prior artifacts, etc.)
            
        Returns:
            Dictionary with agent response and metadata
        """
        context = context or {}
        
        # Hypothetical OpenAI SDK usage (placeholder)
        # In real implementation, using Assistants API:
        # assistant = openai.beta.assistants.create(
        #     model="gpt-4",
        #     instructions=self.system_prompt,
        #     tools=[...],  # MCP tools would be configured here
        # )
        # thread = openai.beta.threads.create()
        # message = openai.beta.threads.messages.create(
        #     thread_id=thread.id,
        #     role="user",
        #     content=user_input
        # )
        # run = openai.beta.threads.runs.create(thread_id=thread.id, assistant_id=assistant.id)
        
        print(f"\n{'='*60}")
        print(f"[{self.command_number}] Executing: {self.title}")
        print(f"Phase: {self.phase}")
        print(f"{'='*60}\n")
        
        # Validate against guardrails
        validation_result = self._validate_guardrails(user_input, context)
        if not validation_result["valid"]:
            return {
                "status": "blocked",
                "agent": self.command_number,
                "title": self.title,
                "reason": validation_result["reason"],
                "output": None
            }
        
        # Simulate agent execution
        print(f"System Prompt Preview:\n{self.system_prompt[:200]}...\n")
        print(f"User Input: {user_input}\n")
        print(f"Context Keys: {list(context.keys())}\n")
        
        # In real implementation, this would call the LLM
        simulated_output = self._simulate_execution(user_input, context)
        
        return {
            "status": "success",
            "agent": self.command_number,
            "title": self.title,
            "output": simulated_output,
            "phase": self.phase
        }
    
    def _validate_guardrails(self, user_input: str, context: Dict) -> Dict[str, Any]:
        """Validate action against configured guardrails."""
        # Check if agent is attempting forbidden actions
        forbidden_keywords = self.guardrails.get("forbidden_keywords", [])
        
        for keyword in forbidden_keywords:
            if keyword.lower() in user_input.lower():
                return {
                    "valid": False,
                    "reason": f"Forbidden action detected: {keyword}"
                }
        
        # All checks passed
        return {"valid": True, "reason": None}
    
    def _simulate_execution(self, user_input: str, context: Dict) -> str:
        """Simulate agent execution for demonstration purposes."""
        return f"""
[Simulated Output from {self.title}]

This is a hypothetical response. In a real implementation, this would be
generated by the OpenAI Agent SDK based on:
- System Prompt: {self.title}
- User Input: {user_input}
- Context: {context}
- Phase: {self.phase}

The agent would perform its defined steps and return structured output
according to the markdown specification.
"""


class AgentFactory:
    """Factory for creating agent instances from markdown definitions."""
    
    def __init__(self, parser):
        """
        Initialize the AgentFactory.
        
        Args:
            parser: MarkdownParser instance for reading agent definitions
        """
        self.parser = parser
        self.guardrails = {}
        
    def load_guardrails(self, forbidden_md_path: Path) -> Dict[str, Any]:
        """
        Load guardrails from the forbidden.md file.
        
        Args:
            forbidden_md_path: Path to support/01-forbidden.md
            
        Returns:
            Dictionary of guardrails configuration
        """
        with open(forbidden_md_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Extract forbidden actions
        forbidden_section = self._extract_forbidden_section(content)
        
        # Parse forbidden keywords/patterns
        forbidden_keywords = self._extract_forbidden_keywords(content)
        
        self.guardrails = {
            "forbidden_content": forbidden_section,
            "forbidden_keywords": forbidden_keywords,
            "principles": self._extract_principles(content)
        }
        
        return self.guardrails
    
    def _extract_forbidden_section(self, content: str) -> str:
        """Extract the forbidden actions section."""
        match = re.search(
            r'##\s+Forbidden Actions\s*\n(.*?)(?=^##\s|\Z)',
            content,
            re.MULTILINE | re.DOTALL
        )
        return match.group(1).strip() if match else ""
    
    def _extract_forbidden_keywords(self, content: str) -> list:
        """Extract forbidden action keywords."""
        keywords = []
        
        # Look for lines starting with ❌
        matches = re.findall(r'❌\s+(?:Do not|Never|No)\s+(.+?)(?:\.|$)', content)
        
        for match in matches:
            # Extract key forbidden concepts
            if "time estimate" in match.lower():
                keywords.append("time estimate")
            if "code" in match.lower() and "planning" in match.lower():
                keywords.append("generate code in planning")
            if "next steps" in match.lower():
                keywords.append("next steps")
                
        return keywords
    
    def _extract_principles(self, content: str) -> list:
        """Extract global principles."""
        principles = []
        
        # Look for lines with checkmarks
        matches = re.findall(r'[-*]\s+\*\*([^:]+):\*\*\s+(.+)', content)
        
        for principle, description in matches:
            principles.append({
                "name": principle.strip(),
                "description": description.strip()
            })
            
        return principles
    
    def create_agent(self, command_number: str) -> Optional[Agent]:
        """
        Create an agent instance for a specific command number.
        
        Args:
            command_number: Command number (e.g., "22" for architect)
            
        Returns:
            Agent instance or None if not found
        """
        all_agents = self.parser.parse_all_commands()
        
        if command_number in all_agents:
            agent_def = all_agents[command_number]
            return Agent(agent_def, self.guardrails)
        
        return None
    
    def create_all_agents(self) -> Dict[str, Agent]:
        """
        Create agent instances for all available commands.
        
        Returns:
            Dictionary mapping command numbers to Agent instances
        """
        all_defs = self.parser.parse_all_commands()
        agents = {}
        
        for cmd_num, agent_def in all_defs.items():
            agents[cmd_num] = Agent(agent_def, self.guardrails)
            
        return agents
    
    def get_agents_by_phase(self, phase: str) -> list:
        """
        Get all agents for a specific workflow phase.
        
        Args:
            phase: Phase name (e.g., "Planning", "Development")
            
        Returns:
            List of Agent instances for that phase
        """
        phases = self.parser.get_commands_by_phase()
        
        if phase not in phases:
            return []
        
        return [Agent(agent_def, self.guardrails) for agent_def in phases[phase]]
